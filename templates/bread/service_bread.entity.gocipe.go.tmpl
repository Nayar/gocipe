package {{lower .Entity.Name}}

import (
	"github.com/pkg/errors"
	"golang.org/x/net/context"
)

// Service represents implementation of BREAD service to Browse, Read, Edit, Add and Delete entities
type Service struct {
	DB *sql.DB
}

{{if .Entity.Bread.Create -}}
// Create{{.Entity.Name}} allows creation of entity of type {{.Entity.Name}}
func(s Service) Create{{.Entity.Name}}(ctx context.Context, req *CreateRequest) (*CreateResponse, error) {
	var (
		err  error
		tx   *sql.Tx
		res  CreateResponse
		{{if or .Entity.Bread.Hooks.PreCreate .Entity.Bread.Hooks.PostCreate -}}
		stop bool
		{{- end}}
	)

	if req == nil {
		return nil, bread.ErrorRequestEmpty
	}

	if req.{{.Entity.Name}} == nil {
		res.{{.Entity.Name}} = make({{.Entity.Name}})
	} else {
		res.{{.Entity.Name}} = req.{{.Entity.Name}}
	}
	tx, err = s.DB.Begin()
	{{if .Entity.Bread.Hooks.PreCreate}}
	stop, err = s.{{lower .Entity.Name}}PreCreate(ctx, tx, req, &res, err)
	if stop {
		return &res, nil
	}
	{{- end}}

	if err != nil {
		return nil, errors.WithStack(err)
	}

	err = models.{{.Entity.Name}}Repo.Save(ctx, res.{{.Entity.Name}}, tx, true)

	{{if .Entity.Bread.Hooks.PostCreate -}}
	stop, err = s.{{lower .Entity.Name}}PostCreate(ctx, req, &res, err)
	if stop {
		return &res, nil
	}
	{{- end}}

	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, errors.WithStack(err)
}
{{- end}}

{{if .Entity.Bread.Read -}}
// Get{{.Entity.Name}} allows getting a single entity of type {{.Entity.Name}}
func(s Service) Get{{.Entity.Name}}(ctx context.Context, req *bread.GetRequest) (*bread.GetResponse, error) {
	var (
		res  Get{{.Entity.Name}}Response
		err  error
		{{if or .Entity.Bread.Hooks.PreRead .Entity.Bread.Hooks.PostRead -}}
		stop bool
		{{- end}}
	)

	if req == nil || req.ID == "" {
		return nil, bread.ErrorRequestEmpty
	}

	{{if .Entity.Bread.Hooks.PreRead}}
	stop, err = s.{{lower .Entity.Name}}PreRead(ctx, req, &res)
	if stop {
		return &res, nil
	}
	{{- end}}

	res.{{.Entity.Name}}, err = models.{{.Entity.Name}}Repo.GetWithRel(ctx, req.ID)

	{{if .Entity.Bread.Hooks.PostRead -}}
	stop, err = s.{{lower .Entity.Name}}PostRead(ctx, req, &res, err)
	if stop {
		return &res, nil
	}
	{{- end}}

	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, nil
}
{{- end}}

{{if .Entity.Bread.List -}}
// List{{plural .Entity.Name}} allows listing all entity of type {{.Entity.Name}}
func(s Service) List{{plural .Entity.Name}}(ctx context.Context, req *List{{plural .Entity.Name}}Request) (*List{{plural .Entity.Name}}Response, error) {
	var (
		res  List{{plural .Entity.Name}}Response
		err  error
		{{if or .Entity.Bread.Hooks.PreList .Entity.Bread.Hooks.PostList -}}
		stop bool
		{{- end}}
		filters []*models.Filter
	)

	if req == nil {
		return nil, bread.ErrorRequestEmpty
	}

	{{if .Entity.Bread.Hooks.PreList -}}
	stop, err = s.{{lower .Entity.Name}}PreList(ctx, req, &res)
	if stop {
		return &res, nil
	}
	{{- end}}

	if req.ListOpts == nil {
		req.ListOpts = &models.ListOpts{Offset: models.NoOffset, Limit: models.NoLimit}
	}

	{{$filters := getBreadFilters .Entity.Fields }}
	{{if (or $filters.HasBool $filters.HasString $filters.HasDate)}}
	if req.Filters != nil {
		for i := range req.Filters {
			switch req.Filters[i].Field {
			{{if $filters.HasBool}}
			case {{$filters.BoolFilters}}:
				if f, err := bread.newBoolFilter(req.Filters[i]); err == nil {
					return nil, err
				} else {
					filters = append(filters, f)
				}
			{{end}}
			{{if $filters.HasString}}
			case {{$filters.StringFilters}}:
				if f, err := bread.newStringFilter(req.Filters[i]); err == nil {
					return nil, err
				} else {
					filters = append(filters, f)
				}
			{{end}}
			{{if $filters.HasDate}}
			case {{$filters.DateFilters}}:
				if f, err := bread.newDateFilter(req.Filters[i]); err == nil {
					return nil, err
				} else {
					filters = append(filters, f)
				}
			{{end}}
			}
		}
	}
	{{end}}

	res.{{plural .Entity.Name}}, err = models.{{.Entity.Name}}Repo.ListWithRel(ctx, req.ListOpts, filters...)

	{{if .Entity.Bread.Hooks.PostList -}}
	stop, err = s.{{lower .Entity.Name}}PostList(ctx, req, &res, err)
	if stop {
		return &res, nil
	}
	{{- end}}
	
	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, nil
}
{{- end}}

{{if .Entity.Bread.Update -}}
// Update{{.Entity.Name}} allows updating one entity of type {{.Entity.Name}}
func(s Service) Update{{.Entity.Name}}(ctx context.Context, req *Update{{.Entity.Name}}Request) (*Update{{.Entity.Name}}Response, error) {
	var (
		err  error
		tx   *sql.Tx
		res  Update{{.Entity.Name}}Response
		{{if or .Entity.Bread.Hooks.PreUpdate .Entity.Bread.Hooks.PostUpdate -}}
		stop bool
		{{- end}}
	)

	if req == nil || req.{{.Entity.Name}} == nil {
		return nil, bread.ErrorRequestEmpty
	}

	{{if or .Entity.Bread.Hooks.PreUpdate .Entity.Bread.Hooks.PostUpdate -}}
	filespath := make(map[string]string)
	{{- end}}

	// existing records in DB
	existing, err := models.{{.Entity.Name}}Repo.Get(ctx, req.{{.Entity.Name}}.ID)
	if err != nil {
		{{if .Entity.Bread.Hooks.PreUpdate -}}
		stop, err = s.{{lower .Entity.Name}}PreUpdate(ctx, tx, req, &res, *existing, err)
		if stop {
			return &res, nil
		}
		{{end}}
		return nil, errors.WithStack(err)
	}

	res.{{.Entity.Name}} = req.{{.Entity.Name}}
	tx, err = s.DB.Begin()

	{{if .Entity.Bread.Hooks.PreUpdate -}}
	stop, err = s.{{lower .Entity.Name}}PreUpdate(ctx, tx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}
	{{- end}}

	if err != nil {
		return nil, errors.WithStack(err)
	}

	err = models.{{.Entity.Name}}Repo.SaveWithRel(ctx, res.{{.Entity.Name}}, tx, true)
	if err != nil {
		return nil, errors.WithStack(err)
	}

	{{if .Entity.Bread.Hooks.PostUpdate -}}
	stop, err = s.{{lower .Entity.Name}}PostUpdate(ctx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}
	{{- end}}

	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, nil
}
{{- end}}

{{if .Entity.Bread.Delete -}}
// Delete{{.Entity.Name}} allows deleting an entity of type {{.Entity.Name}}
func(s Service) Delete{{.Entity.Name}}(ctx context.Context, req *bread.Delete{{.Entity.Name}}Request) (*Delete{{.Entity.Name}}bread.DeleteResponse, error) {
	var (
		err  error
		tx   *sql.Tx
		res  Delete{{.Entity.Name}}Response
		{{if or .Entity.Bread.Hooks.PreDelete .Entity.Bread.Hooks.PostDelete -}}
		stop bool
		{{- end}}
	)

	if req == nil || req.ID == "" {
		return nil, bread.ErrorRequestEmpty
	}

	// existing records in DB
	existing, err := models.{{.Entity.Name}}Repo.Get(ctx, req.ID)
	if err != nil {
		{{if .Entity.Bread.Hooks.PreDelete -}}
		stop, err = s.{{lower .Entity.Name}}PreDelete(ctx, tx, req, &res, *existing, err)
		if stop {
			return &res, nil
		}
		{{end}}
		return nil, errors.WithStack(err)
	}

	tx, err = s.DB.Begin()
	{{if .Entity.Bread.Hooks.PreDelete}}
	stop, err = s.{{lower .Entity.Name}}PreDelete(ctx, tx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}
	{{end}}
	err = models.{{.Entity.Name}}Repo.Delete(ctx, existing, tx, true)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	{{if .Entity.Bread.Hooks.PostDelete}}
	stop, err = s.{{lower .Entity.Name}}PostDelete(ctx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}
	{{- end}}
	
	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, nil
}
{{- end}}
{{if .HasFileFields}}
// Upload{{.Entity.Name}} Upload allows uploading of files for entity of type {{.Entity.Name}}
func(s Service) Upload{{.Entity.Name}}(ctx context.Context, req *bread.UploadRequest) (*bread.UploadResponse, error) {
destination := path.Join(options.Entity, id, options.Field)
	var res bread.UploadResponse

	if req == nil {
		return &res, bread.ErrorRequestEmpty
	}

	switch req.Field {
		case {{.FileFields}}:
			//do nothing
		default:
			return &res, bread.ErrorInvalidUploadField
	}

	filePath, fileName, err := files.Upload(req.Filename, req.Content, options)
	if err != nil {
		if filePath != "" {
			files.Delete(filePath)
		}
		return &res, nil
	}

	if err = util.CheckContext(ctx); err != nil {
		files.Delete(filePath)
		return errors.WithStack(err)
	}

	tx, err = models.StartTransaction()
	if err != nil {
		files.Delete(filePath)
		return &res, err
	}
	
	stmt, err = tx.Prepare(`UPDATE {{.Table}} SET {{.SQLFields}} = $1 WHERE id = $2`) //TODO
	if err != nil {
		files.Delete(filePath)
		return &res, errors.WithStack(err)
	}

	_, err = stmt.Exec(fileName, req.ID)
	if err != nil {
		tx.Rollback()
		files.Delete(filePath)
		return &res, errors.WithStack(err)
	}
	
	res.URI = options.MediaPrefixURL + "/" + fileName
	return &res, nil
}
{{- end}}