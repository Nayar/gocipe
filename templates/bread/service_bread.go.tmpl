package bread

import (
	"github.com/pkg/errors"
	"golang.org/x/net/context"
	"lsl.digital/auth-system/id-sdk-go/auth"
)

var (
	ErrorInvalidOperation = errors.New("invalid filter operation specified")
	ErrorRequestEmpty = errors.New("request object is malformed")
)

// Service represents implementation of BREAD service to Browse, Read, Edit, Add and Delete entities
type Service struct {
	DB         *sql.DB
	AuthClient auth.WireClient
}

{{range .Entities}}
{{if .Bread.Create -}}
// Create{{.Name}} allows creation of entity of type {{.Name}}
func(s Service) Create{{.Name}}(ctx context.Context, req *Create{{.Name}}Request) (*Create{{.Name}}Response, error) {
	var (
		err  error
		tx   *sql.Tx
		res  Create{{.Name}}Response
		{{if or .Bread.Hooks.PreCreate .Bread.Hooks.PostCreate -}}
		stop bool
		{{- end}}
	)

	if req == nil || req.{{.Name}} == nil {
		return nil, ErrorRequestEmpty
	}

	res.{{.Name}} = req.{{.Name}}
	tx, err = s.DB.Begin()
	{{if .Bread.Hooks.PreCreate}}
	stop, err = {{lower .Name}}PreCreate(ctx, tx, req, &res, err)
	if stop {
		return &res, nil
	}
	{{- end}}

	if err != nil {
		return nil, errors.WithStack(err)
	}

	err = models.{{.Name}}Repo.SaveWithRel(ctx, res.{{.Name}}, tx, true)

	{{if .Bread.Hooks.PostCreate -}}
	stop, err = {{lower .Name}}PostCreate(ctx, req, &res, err)
	if stop {
		return &res, nil
	}
	{{- end}}

	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, errors.WithStack(err)
}
{{- end}}

{{if .Bread.Read -}}
// Get{{.Name}} allows getting a single entity of type {{.Name}}
func(s Service) Get{{.Name}}(ctx context.Context, req *Get{{.Name}}Request) (*Get{{.Name}}Response, error) {
	var (
		res  Get{{.Name}}Response
		err  error
		{{if or .Bread.Hooks.PreRead .Bread.Hooks.PostRead -}}
		stop bool
		{{- end}}
	)

	if req == nil || req.ID == "" {
		return nil, ErrorRequestEmpty
	}

	{{if .Bread.Hooks.PreRead}}
	stop, err = {{lower .Name}}PreRead(ctx, req, &res)
	if stop {
		return &res, nil
	}
	{{- end}}

	res.{{.Name}}, err = models.{{.Name}}Repo.GetWithRel(ctx, req.ID)

	{{if .Bread.Hooks.PostRead -}}
	stop, err = {{lower .Name}}PostRead(ctx, req, &res, err)
	if stop {
		return &res, nil
	}
	{{- end}}

	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, nil
}
{{- end}}

{{if .Bread.List -}}
// List{{plural .Name}} allows listing all entity of type {{.Name}}
func(s Service) List{{plural .Name}}(ctx context.Context, req *List{{plural .Name}}Request) (*List{{plural .Name}}Response, error) {
	var (
		res  List{{plural .Name}}Response
		err  error
		{{if or .Bread.Hooks.PreList .Bread.Hooks.PostList -}}
		stop bool
		{{- end}}
		filters []*models.Filter
	)

	if req == nil || req.Filters == nil || req.ListOpts == nil {
		return nil, ErrorRequestEmpty
	}

	{{if .Bread.Hooks.PreList -}}
	stop, err = {{lower .Name}}PreList(ctx, req, &res)
	if stop {
		return &res, nil
	}
	{{- end}}

	{{$filters := getBreadFilters .Fields }}
	{{if (or $filters.HasBool $filters.HasString $filters.HasDate)}}
	for i := range req.Filters {
		switch req.Filters[i].Field {
		{{if $filters.HasBool}}
		case {{$filters.BoolFilters}}:
			if f, err := newBoolFilter(req.Filters[i]); err == nil {
				return nil, err
			} else {
				filters = append(filters, f)
			}
		{{end}}
		{{if $filters.HasString}}
		case {{$filters.StringFilters}}:
			if f, err := newStringFilter(req.Filters[i]); err == nil {
				return nil, err
			} else {
				filters = append(filters, f)
			}
		{{end}}
		{{if $filters.HasDate}}
		case {{$filters.DateFilters}}:
			if f, err := newDateFilter(req.Filters[i]); err == nil {
				return nil, err
			} else {
				filters = append(filters, f)
			}
		{{end}}
		}
	}
	{{end}}

	res.{{plural .Name}}, err = models.{{.Name}}Repo.ListWithRel(ctx, req.ListOpts, filters...)

	{{if .Bread.Hooks.PostList -}}
	stop, err = {{lower .Name}}PostList(ctx, req, &res, err)
	if stop {
		return &res, nil
	}
	{{- end}}
	
	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, nil
}
{{- end}}

{{if .Bread.Update -}}
// Update{{.Name}} allows updating one entity of type {{.Name}}
func(s Service) Update{{.Name}}(ctx context.Context, req *Update{{.Name}}Request) (*Update{{.Name}}Response, error) {
	var (
		err  error
		tx   *sql.Tx
		res  Update{{.Name}}Response
		{{if or .Bread.Hooks.PreUpdate .Bread.Hooks.PostUpdate -}}
		stop bool
		{{- end}}
	)

	if req == nil || req.{{.Name}} == nil {
		return nil, ErrorRequestEmpty
	}

	// existing records in DB
	existing, err := models.{{.Name}}Repo.Get(ctx, req.{{.Name}}.ID)
	if err != nil {
		{{if .Bread.Hooks.PreUpdate -}}
		stop, err = {{lower .Name}}PreUpdate(ctx, tx, req, &res, *existing, err)
		if stop {
			return &res, nil
		}
		{{end}}
		return nil, errors.WithStack(err)
	}

	res.{{.Name}} = req.{{.Name}}
	tx, err = s.DB.Begin()

	{{if .Bread.Hooks.PreUpdate -}}
	stop, err = {{lower .Name}}PreUpdate(ctx, tx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}
	{{- end}}

	if err != nil {
		return nil, errors.WithStack(err)
	}

	err = models.{{.Name}}Repo.SaveWithRel(ctx, res.{{.Name}}, tx, true)
	if err != nil {
		return nil, errors.WithStack(err)
	}

	{{if .Bread.Hooks.PostUpdate -}}
	stop, err = {{lower .Name}}PostUpdate(ctx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}
	{{- end}}

	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, nil
}
{{- end}}

{{if .Bread.Delete -}}
// Delete{{.Name}} allows deleting an entity of type {{.Name}}
func(s Service) Delete{{.Name}}(ctx context.Context, req *Delete{{.Name}}Request) (*Delete{{.Name}}Response, error) {
	var (
		err  error
		tx   *sql.Tx
		res  Delete{{.Name}}Response
		{{if or .Bread.Hooks.PreDelete .Bread.Hooks.PostDelete -}}
		stop bool
		{{- end}}
	)

	if req == nil || req.ID == "" {
		return nil, ErrorRequestEmpty
	}

	// existing records in DB
	existing, err := models.{{.Name}}Repo.Get(ctx, req.ID)
	if err != nil {
		{{if .Bread.Hooks.PreDelete -}}
		stop, err = {{lower .Name}}PreDelete(ctx, tx, req, &res, *existing, err)
		if stop {
			return &res, nil
		}
		{{end}}
		return nil, errors.WithStack(err)
	}

	tx, err = s.DB.Begin()
	{{if .Bread.Hooks.PreDelete}}
	stop, err = {{lower .Name}}PreDelete(ctx, tx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}
	{{end}}
	err = models.{{.Name}}Repo.Delete(ctx, existing, tx, true)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	{{if .Bread.Hooks.PostDelete}}
	stop, err = {{lower .Name}}PostDelete(ctx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}
	{{- end}}
	
	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, nil
}
{{- end}}
{{end}}

func newBoolFilter(filter *Filter) (*models.Filter, error) {
	value, err := strconv.ParseBool(filter.Value); 
	
	if err != nil {
		return nil, err
	}

	return &models.Filter{Field: filter.Field, Operation: "=", Value: value}, nil
}

func newStringFilter(filter *Filter) (*models.Filter, error) {
	switch filter.Operation {
	case "=":
		return &models.Filter{Field: filter.Field, Operation: "=", Value: filter.Value}, nil
	case "~":
		return &models.Filter{Field: filter.Field, Operation: "LIKE", Value: filter.Value}, nil
	}

	return nil, ErrorInvalidOperation
}

func newDateFilter(filter *Filter) (*models.Filter, error) {
	var (
		value time.Time
		err   error
	)

	if value, err = time.Parse(time.RFC3339, filter.Value); err != nil {
		return nil, err
	}

	switch filter.Operation {
	case "=":
		return &models.Filter{Field: filter.Field, Operation: "=", Value: value}, nil
	case ">":
		return &models.Filter{Field: filter.Field, Operation: ">", Value: value}, nil
	case ">=":
		return &models.Filter{Field: filter.Field, Operation: ">=", Value: value}, nil
	case "<":
		return &models.Filter{Field: filter.Field, Operation: "<", Value: value}, nil
	case "<=":
		return &models.Filter{Field: filter.Field, Operation: "<=", Value: value}, nil
	}

	return &models.Filter{Field: filter.Field, Operation: "LIKE", Value: value}, nil
}
