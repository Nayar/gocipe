
// List returns a slice containing {{.EntityName}} records
func (repo {{.EntityName}}Repositorium) List(ctx context.Context, offset int, limit int, filters ...*ListFilter) ([]*{{.EntityName}}, error) {
	var (
		list     []*{{.EntityName}}
		segments []string
		values   []interface{}
		err      error
		rows     *sql.Rows
	)

	query := `SELECT {{.SQLFields}} FROM {{.Table}} t`
	{{if .HasPreHook}}
    if filters, err = repo.preList(ctx, filters); err != nil {
		return nil, err
	}
	{{end}}
	if err = util.CheckContext(ctx); err != nil {
		return nil, err
	}

	for i, filter := range filters {
		if filter.GetOperation() == "IN" || filter.GetOperation() == "NOT IN" {
			QueryAddIN(segments, values, &i, filter.GetField(), filter.GetValue(), "NOT IN" == filter.GetOperation())
		} else {
			segments = append(segments, filter.GetField()+" "+filter.GetOperation()+" $"+strconv.Itoa(i+1))
			values = append(values, filter.GetValue())
		}
	}

	if len(segments) != 0 {
		query += " WHERE " + strings.Join(segments, " AND ")
	}

	query += " ORDER BY t.id ASC"

	if limit > NoLimit {
		query += " LIMIT "+strconv.Itoa(limit)
	}

	if offset > NoOffset {
		query += " OFFSET "+strconv.Itoa(limit)
	}

	rows, err = repo.db.Query(query, values...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()
	for rows.Next() {
		if err = util.CheckContext(ctx); err != nil {
			return nil, err
		}

		var entity {{.EntityName}}
		{{range .Before}}{{.}}
		{{end}}

		err = rows.Scan({{.StructFields}})
		if err != nil {
			return nil, err
		}
		
		{{range .After}}{{.}}
		{{end}}

		list = append(list, &entity)
	}
	{{if .HasPostHook}}
	if err = util.CheckContext(ctx); err != nil {
		return nil, err
	}

	if list, err = repo.postList(ctx, list); err != nil {
		return nil, err
	}
	{{end}}
	return list, nil
}

// ListWithRel returns a slice containing {{.EntityName}} records; will also load related entities.
func (repo {{.EntityName}}Repositorium) ListWithRel(ctx context.Context, offset int, limit int, filters ...*ListFilter) ([]*{{.EntityName}}, error) {
	var (
		err error
		entities []*{{.EntityName}}
	)

	entities, err = repo.List(ctx, offset, limit, filters...)
	if err != nil {
		return nil, err
	}

	{{range .Related}}{{.}}
	if err != nil {
		return nil, err
	}

	if err = util.CheckContext(ctx); err != nil {
		return nil, err
	}
	{{end}}

	return entities, nil
}

// Select returns a slice containing {{.EntityName}} records according to a custom SQL condition
func (repo {{.EntityName}}Repositorium) Select(ctx context.Context, offset int, limit int, condition string, values ...interface{}) ([]*{{.EntityName}}, error) {
	var (
		list     []*{{.EntityName}}
		err      error
		rows     *sql.Rows
	)

	query := `SELECT {{.SQLFields}} FROM {{.Table}} t ` + condition
	if err = util.CheckContext(ctx); err != nil {
		return nil, err
	}

	query += " ORDER BY id ASC"

	if limit > -1 {
		query += " LIMIT "+strconv.Itoa(limit)
	}

	if offset > -1 {
		query += " OFFSET "+strconv.Itoa(limit)
	}

	rows, err = repo.db.Query(query, values...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()
	for rows.Next() {
		if err = util.CheckContext(ctx); err != nil {
			return nil, err
		}

		var entity {{.EntityName}}
		{{range .Before}}{{.}}
		{{end}}

		err = rows.Scan({{.StructFields}})
		if err != nil {
			return nil, err
		}
		
		{{range .After}}{{.}}
		{{end}}

		list = append(list, &entity)
	}

	return list, nil
}

// SelectWithRel returns a slice containing {{.EntityName}} records according to a custom SQL condition; will also load related entities.
func (repo {{.EntityName}}Repositorium) SelectWithRel(ctx context.Context, offset int, limit int, condition string, values ...interface{}) ([]*{{.EntityName}}, error) {
	var (
		err error
		entities []*{{.EntityName}}
	)

	entities, err = repo.Select(ctx, offset, limit, condition, values...)
	if err != nil {
		return nil, err
	}

	{{range .Related}}{{.}}
	if err != nil {
		return nil, err
	}

	if err = util.CheckContext(ctx); err != nil {
		return nil, err
	}
	{{end}}

	return entities, nil
}