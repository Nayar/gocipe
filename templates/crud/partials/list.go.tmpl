
// List returns a slice containing {{.EntityName}} records
func (repo {{.EntityName}}Repositorium) List(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*{{.EntityName}}, error) {
	var (
		list	 []*{{.EntityName}}
		segments []string
		values	 []interface{}
		err		 error
		rows	 *sql.Rows
		index	 int = 0
	)

	query := `SELECT {{.SQLFields}} FROM {{.Table}} t`
	{{if .HasPreHook}}
    if filters, err = repo.preList(ctx, filters); err != nil {
		return nil, err
	}
	{{end}}
	if err = util.CheckContext(ctx); err != nil {
		return nil, err
	}

	for _, filter := range filters {
		if filter.Operation == "IN" || filter.Operation == "NOT IN" {
			seg, val, err := QueryAddIN(segments, values, &index, filter.Field, filter.Value, "NOT IN" == filter.Operation)
			if err != nil {
				continue
			}
			segments = seg
			values = val
		} else {
			index += 1
			segments = append(segments, filter.Field+" "+filter.Operation+" $"+strconv.Itoa(index))
			values = append(values, filter.Value)
		}
	}

	if len(segments) != 0 {
		query += " WHERE " + strings.Join(segments, " AND ")
	}

	if opts != nil && opts.Sort != "" {
		query += " ORDER BY " + opts.Sort
	}

	if opts != nil && opts.Offset > 0 {
		query += " OFFSET " + strconv.FormatInt(opts.Offset, 10)
	}

	if opts != nil && opts.Limit > 0 {
		query += " LIMIT " + strconv.FormatInt(opts.Limit, 10)
	}

	rows, err = repo.db.Query(query, values...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()
	for rows.Next() {
		if err = util.CheckContext(ctx); err != nil {
			return nil, err
		}

		var entity {{.EntityName}}
		{{range .Before}}{{.}}
		{{end}}

		err = rows.Scan({{.StructFields}})
		if err != nil {
			return nil, err
		}
		
		{{range .After}}{{.}}
		{{end}}

		list = append(list, &entity)
	}
	{{if .HasPostHook}}
	if err = util.CheckContext(ctx); err != nil {
		return nil, err
	}

	if list, err = repo.postList(ctx, list); err != nil {
		return nil, err
	}
	{{end}}
	return list, nil
}

// ListWithRel returns a slice containing {{.EntityName}} records; will also load related entities.
func (repo {{.EntityName}}Repositorium) ListWithRel(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*{{.EntityName}}, error) {
	var (
		err error
		entities []*{{.EntityName}}
	)

	entities, err = repo.List(ctx, opts, filters...)
	if err != nil {
		return nil, err
	}

	{{range .Related}}{{.}}
	if err != nil {
		return nil, err
	}

	if err = util.CheckContext(ctx); err != nil {
		return nil, err
	}
	{{end}}

	return entities, nil
}

// Select returns a slice containing {{.EntityName}} records according to a custom SQL condition
func (repo {{.EntityName}}Repositorium) Select(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*{{.EntityName}}, error) {
	var (
		list     []*{{.EntityName}}
		err      error
		rows     *sql.Rows
	)

	query := `SELECT {{.SQLFields}} FROM {{.Table}} t ` + condition
	if err = util.CheckContext(ctx); err != nil {
		return nil, err
	}

	if opts != nil {
		switch opts.Sort {
		case {{.OrderFields}}:
			query += ` ORDER BY t."` + opts.Sort + `"`
		}
	}

	if opts != nil && opts.Offset > 0 {
		query += " OFFSET " + strconv.FormatInt(opts.Offset, 10)
	}

	if opts != nil && opts.Limit > 0 {
		query += " LIMIT " + strconv.FormatInt(opts.Limit, 10)
	}

	rows, err = repo.db.Query(query, values...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()
	for rows.Next() {
		if err = util.CheckContext(ctx); err != nil {
			return nil, err
		}

		var entity {{.EntityName}}
		{{range .Before}}{{.}}
		{{end}}

		err = rows.Scan({{.StructFields}})
		if err != nil {
			return nil, err
		}
		
		{{range .After}}{{.}}
		{{end}}

		list = append(list, &entity)
	}

	return list, nil
}

// SelectWithRel returns a slice containing {{.EntityName}} records according to a custom SQL condition; will also load related entities.
func (repo {{.EntityName}}Repositorium) SelectWithRel(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*{{.EntityName}}, error) {
	var (
		err error
		entities []*{{.EntityName}}
	)

	entities, err = repo.Select(ctx, opts, condition, values...)
	if err != nil {
		return nil, err
	}

	{{range .Related}}{{.}}
	if err != nil {
		return nil, err
	}

	if err = util.CheckContext(ctx); err != nil {
		return nil, err
	}
	{{end}}

	return entities, nil
}
