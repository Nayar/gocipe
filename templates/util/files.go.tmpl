package files

import (
	"fmt"
	"image"
	"image/gif"
	"image/jpeg"
	"image/png"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"
	"time"

	"github.com/disintegration/imaging"
	"github.com/pkg/errors"
	"gopkg.in/h2non/filetype.v1"

	"github.com/muesli/smartcrop"
	"github.com/muesli/smartcrop/nfnt"

	"github.com/gosimple/slug"
)

// Constants for files package
const (
	// NoLimit is used to indicate no restriction (on dimensions or size)
	NoLimit = -1

	_fileMode = os.FileMode(0644)
)

// ImageDimensions holds dimensions options
type ImageDimensions struct {
	ThumbWidth     int
	ThumbHeight    int
	MinWidth       int
	MinHeight      int
	MaxWidth       int
	MaxHeight      int
	GenerateSocial bool
}

// UploadOptions holds file upload options
type UploadOptions struct {
	Dir            string
	Destination    string
	MediaPrefixURL string
	FileType       int
	MaxSize        int
	MinSize        int
	ImgDimensions  *ImageDimensions
}

type subImager interface {
	SubImage(r image.Rectangle) image.Image
}

// supported file types by fileupload
const (
	TypeInvalid = iota
	TypeImage
	TypeVideo
)

var (
	// DefaultUploadOptions holds default upload options
	DefaultUploadOptions = &UploadOptions{
		FileType: TypeImage,
		MaxSize:  NoLimit,
		MinSize:  NoLimit,
		ImgDimensions: &ImageDimensions{
			MinWidth:  NoLimit,
			MinHeight: NoLimit,
			MaxWidth:  NoLimit,
			MaxHeight: NoLimit,
		},
	}

	typeWhitelist map[int][]string
)

func init() {
	typeWhitelist = make(map[int][]string)
	typeWhitelist[TypeImage] = []string{"jpg", "jpeg", "png"}
	typeWhitelist[TypeVideo] = []string{"mp4"}

	image.RegisterFormat("jpeg", "jpeg", jpeg.Decode, jpeg.DecodeConfig)
	image.RegisterFormat("png", "png", png.Decode, png.DecodeConfig)
	image.RegisterFormat("gif", "gif", gif.Decode, gif.DecodeConfig)
}

// Upload validates and saves create file
func Upload(fileName string, fileContent []byte, options *UploadOptions) (string, string, error) {
	dirPath := path.Join(options.Dir, options.Destination)
	fileName = buildFileName(fileName)
	filePath := path.Join(options.MediaPrefixURL, options.Destination, fileName)
	fileDiskPath := filepath.Join(dirPath, fileName)

	// Create full directory structure to store image
	if err := os.MkdirAll(dirPath, os.ModePerm); err != nil {
		log.Printf("error creating directories: %v\n", err)
		return fileDiskPath, filePath, err
	}

	// Create file on disk if it does not exist
	if _, err := os.Stat(fileDiskPath); os.IsNotExist(err) {
		if err := ioutil.WriteFile(fileDiskPath, fileContent, _fileMode); err != nil {
			log.Printf("error writing %v: %v\n", fileDiskPath, err)
			return fileDiskPath, filePath, err
		}
	}

	file, err := os.Open(fileDiskPath)
	if err != nil {
		log.Printf("error opening %v: %v\n", fileDiskPath, err)
		return fileDiskPath, filePath, err
	}
	defer file.Close()

	buf, err := ioutil.ReadFile(fileDiskPath)
	if err != nil {
		log.Printf("error reading %v: %v\n", fileDiskPath, err)
		return fileDiskPath, filePath, err
	}

	fileSize := len(buf)

	// Check min and max filesize
	if options.MinSize != NoLimit && fileSize < options.MinSize {
		log.Printf("file %v lower than min file size: %v\n", fileName, options.MinSize)
		return fileDiskPath, filePath, fmt.Errorf("file min size error")
	}

	if options.MaxSize != NoLimit && fileSize > options.MaxSize {
		log.Printf("file %v greater than max file size: %v\n", fileName, options.MaxSize)
		return fileDiskPath, filePath, fmt.Errorf("file max size error")
	}

	switch options.FileType {
	case TypeImage:
		if !filetype.IsImage(buf) {
			return fileDiskPath, filePath, fmt.Errorf("image type invalid")
		}

		img, imgType, err := image.DecodeConfig(file)
		if err != nil {
			log.Printf("error decoding image: %v", err)
			return fileDiskPath, filePath, err
		}

		var extValid bool
		for _, t := range typeWhitelist[TypeImage] {
			if t == imgType {
				extValid = true
				break
			}
		}

		if !extValid {
			return fileDiskPath, filePath, fmt.Errorf("image type %s invalid", imgType)
		}

		fileExt := filepath.Ext(fileDiskPath)
		if fileExt != ".jpg" {
			oldFileDiskPath := fileDiskPath
			oldFilePath := filePath
			fileDiskPath = changeExt(fileDiskPath, fileExt, ".jpg")
			filePath = changeExt(filePath, fileExt, ".jpg")
			if err := os.Rename(oldFileDiskPath, fileDiskPath); err != nil {
				return oldFileDiskPath, oldFilePath, fmt.Errorf("image ext change to jpg failed")
			}
		}

		if options.ImgDimensions == nil {
			options.ImgDimensions = DefaultUploadOptions.ImgDimensions
		}

		// Check min width and height
		if options.ImgDimensions.MinWidth != NoLimit && img.Width < options.ImgDimensions.MinWidth {
			log.Printf("image %v lower than min width: %v\n", fileName, options.ImgDimensions.MinWidth)
			return fileDiskPath, filePath, fmt.Errorf("image width less than %dpx", options.ImgDimensions.MinWidth)
		}

		if options.ImgDimensions.MinHeight != NoLimit && img.Height < options.ImgDimensions.MinHeight {
			log.Printf("image %v lower than min height: %v\n", fileName, options.ImgDimensions.MinHeight)
			return fileDiskPath, filePath, fmt.Errorf("image height less than %dpx", options.ImgDimensions.MinHeight)
		}

		// Check max width and height
		exceedMaxWidth := options.ImgDimensions.MaxWidth != NoLimit && img.Width >= options.ImgDimensions.MaxWidth
		exceedMaxHeight := options.ImgDimensions.MaxHeight != NoLimit && img.Height >= options.ImgDimensions.MaxHeight

		newWidth := options.ImgDimensions.MaxWidth
		newHeight := options.ImgDimensions.MaxHeight

		// Adjust new width and height accordingly
		if exceedMaxWidth && exceedMaxHeight {
			// resize both by width and height
			// image will be smart cropped :)
		} else if exceedMaxWidth {
			// resize proportional to width only
			newHeight = 0
		} else if exceedMaxHeight {
			// resize proportional to height only
			newWidth = 0
		} else {
			// image is never upscaled
			newWidth = img.Width
			newHeight = img.Height
		}

		if err := imageCropAndResize(fileDiskPath, newWidth, newHeight, ""); err != nil {
			return fileDiskPath, filePath, err
		}

		// fire and forget goroutine
		go func() {
			// Create thumbnails
			imageCropAndResize(fileDiskPath, options.ImgDimensions.ThumbWidth, options.ImgDimensions.ThumbHeight, "thumb")

			// Create og aka full view / social
			if options.ImgDimensions.GenerateSocial {
				imageCropAndResize(fileDiskPath, newWidth, newHeight, "social")
			}
		}()
	case TypeVideo:
		return fileDiskPath, filePath, fmt.Errorf("not yet implemented")
	default:
		return fileDiskPath, filePath, fmt.Errorf("file type invalid")
	}

	return fileDiskPath, filePath, nil
}

// Delete deletes one file
func Delete(fp string) error {
	if err := os.Remove(fp); err != nil {
		return err
	}
	return nil
}

func buildFileName(oldFilename string) string {
	oldExt := filepath.Ext(oldFilename)
	newFilename := strings.TrimSuffix(oldFilename, oldExt)
	return slug.Make(newFilename) + "_" + time.Now().Format("20060102150405") + oldExt
}

func changeExt(filename string, oldExt string, newExt string) string {
	filename = strings.TrimSuffix(filename, oldExt)
	return filename + newExt
}

func imageCropAndResize(imgDiskPath string, newWidth int, newHeight int, fileSuffix string) error {
	existingImgFile, err := os.Open(imgDiskPath)
	if err != nil {
		return errors.Wrap(err, "image open error")
	}
	defer existingImgFile.Close()

	img, _, err := image.Decode(existingImgFile)
	if err != nil {
		return errors.Wrap(err, "image decode error")
	}

	if newWidth != 0 && newHeight != 0 {
		analyzer := smartcrop.NewAnalyzer(nfnt.NewDefaultResizer())
		topCrop, err := analyzer.FindBestCrop(img, newWidth, newHeight)
		if err != nil {
			return errors.Wrap(err, "image failed to find best crop")
		}

		img = img.(subImager).SubImage(topCrop)
	}

	dst := imaging.Resize(img, newWidth, newHeight, imaging.Lanczos)

	if fileSuffix != "" {
		imgDiskPath = fmt.Sprintf("%s:%s", imgDiskPath, fileSuffix)
	}

	outputFile, err := os.Create(imgDiskPath)
	if err != nil {
		return errors.Wrap(err, "image create error")
	}

	return jpeg.Encode(outputFile, dst, nil)
}
