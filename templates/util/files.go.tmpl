package files

import (
	"fmt"
	"image"
	"image/gif"
	"image/jpeg"
	"image/png"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"
	"time"

	"gopkg.in/h2non/filetype.v1"
)

// Constants for files package
const (
  // NoLimit is used to indicate no restriction (on dimensions or size)
	NoLimit   = -1

	_fileMode       = os.FileMode(0644)
)

// ImageDimensions holds dimensions options
type ImageDimensions struct {
	MinHeight int
	MaxHeight int
	MinWidth  int
	MaxWidth  int
}

// UploadOptions holds file upload options
type UploadOptions struct {
	Dir 		   string
	Destination    string
	MediaPrefixURL string
	FileExt        string
	MinSize        int
	MaxSize        int
	ImgDimensions  *ImageDimensions
}

var (
	// DefaultUploadOptions holds default upload options
	DefaultUploadOptions = &UploadOptions{
		FileExt:     "jpg",
		MinSize:     NoLimit,
		MaxSize:     NoLimit,
		ImgDimensions: &ImageDimensions{
			MinWidth:  NoLimit,
			MinHeight: NoLimit,
			MaxWidth:  NoLimit,
			MaxHeight: NoLimit,
		},
	}
)

func init() {
	image.RegisterFormat("jpeg", "jpeg", jpeg.Decode, jpeg.DecodeConfig)
	image.RegisterFormat("png", "png", png.Decode, png.DecodeConfig)
	image.RegisterFormat("gif", "gif", gif.Decode, gif.DecodeConfig)
}

// Upload validates and saves create file
func Upload(fileName string, fileContent []byte, options *UploadOptions) (string, string, error) {
	dirPath := path.Join(options.Dir, options.Destination)
	fileName = buildFileName(fileName, options.FileExt)
	filePath := path.Join(options.MediaPrefixURL, options.Destination, fileName)
	fileDiskPath := filepath.Join(dirPath, fileName)

	if err := os.MkdirAll(dirPath, os.ModePerm); err != nil {
		log.Printf("error creating directories: %v\n", err)
		return fileDiskPath, filePath, err
	}

	if _, err := os.Stat(fileDiskPath); os.IsNotExist(err) {
		if err := ioutil.WriteFile(fileDiskPath, fileContent, _fileMode); err != nil {
			log.Printf("error writing %v: %v\n", fileDiskPath, err)
			return fileDiskPath, filePath, err
		}
	}

	file, err := os.Open(fileDiskPath)
	if err != nil {
		log.Printf("error opening %v: %v\n", fileDiskPath, err)
		return fileDiskPath, filePath, err
	}
	defer file.Close()

	buf, err := ioutil.ReadFile(fileDiskPath)
	if err != nil {
		log.Printf("error reading %v: %v\n", fileDiskPath, err)
		return fileDiskPath, filePath, err
	}

	fileSize := len(buf)

	if options.FileExt == "" {
		options.FileExt = DefaultUploadOptions.FileExt
	}

	if !filetype.IsExtension(buf, options.FileExt) {
		log.Printf("file not a valid %v file\n", options.FileExt)
		return fileDiskPath, filePath, fmt.Errorf("file type invalid")
	}

	if options.MaxSize != NoLimit && fileSize > options.MaxSize {
		log.Printf("file %v greater than max file size: %v\n", fileName, options.MaxSize)
		return fileDiskPath, filePath, fmt.Errorf("file max size error")
	}

	if options.MinSize != NoLimit && fileSize < options.MinSize {
		log.Printf("file %v lower than min file size: %v\n", fileName, options.MinSize)
		return fileDiskPath, filePath, fmt.Errorf("file min size error")
	}

	if filetype.IsImage(buf) {
		image, _, err := image.DecodeConfig(file)
		if err != nil {
			log.Printf("error decoding image: %v", err)
			return fileDiskPath, filePath, err
		}

		if options.ImgDimensions == nil {
			options.ImgDimensions = DefaultUploadOptions.ImgDimensions
		}

		if options.ImgDimensions.MaxHeight != NoLimit && image.Height > options.ImgDimensions.MaxHeight {
			log.Printf("image %v greater than max height: %v\n", fileName, options.ImgDimensions.MaxHeight)
			return fileDiskPath, filePath, fmt.Errorf("image max height error")
		}

		if options.ImgDimensions.MinHeight != NoLimit && image.Height < options.ImgDimensions.MinHeight {
			log.Printf("image %v lower than min height: %v\n", fileName, options.ImgDimensions.MinHeight)
			return fileDiskPath, filePath, fmt.Errorf("image min height error")
		}

		if options.ImgDimensions.MaxWidth != NoLimit && image.Width > options.ImgDimensions.MaxWidth {
			log.Printf("image %v greater than max width: %v\n", fileName, options.ImgDimensions.MaxWidth)
			return fileDiskPath, filePath, fmt.Errorf("image max width error")
		}

		if options.ImgDimensions.MinWidth != NoLimit && image.Width < options.ImgDimensions.MinWidth {
			log.Printf("image %v lower than min width: %v\n", fileName, options.ImgDimensions.MinWidth)
			return fileDiskPath, filePath, fmt.Errorf("image min width error")
		}
	}

	return fileDiskPath, filePath, nil
}

// Delete deletes one file
func Delete(fp string) error {
	if err := os.Remove(fp); err != nil {
		return err
	}
	return nil
}

func buildFileName(oldFilename, newExt string) string {
	oldExt := filepath.Ext(oldFilename)
	newFilename := strings.TrimSuffix(oldFilename, oldExt)
	newFilename = newFilename + "_" + time.Now().Format("20060102150405")
	return newFilename + "." + newExt
}
