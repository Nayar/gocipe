package files

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"
	"time"

	"{{.AppImportPath}}/util"
	"{{.AppImportPath}}/util/imagist"

	"github.com/gosimple/slug"
)

// Constants for files package
const (
	_fileMode = os.FileMode(0644)
)

// UploadOptions holds file upload options
type UploadOptions struct {
	Dir            string
	Destination    string
	MediaPrefixURL string
	FileType       int
	MaxSize        int
	ConvertTo      string
	ImgDimensions  *imagist.ImageDimensions
}

// supported file types by fileupload
const (
	TypeInvalid = iota
	TypeImage
	TypeVideo
)

var (
	// DefaultUploadOptions holds default upload options
	DefaultUploadOptions = &UploadOptions{
		FileType:      TypeImage,
		MaxSize:       util.NoLimit,
		ImgDimensions: &imagist.DefaultDimensions,
	}

	_imagist *imagist.Imagist
)

func init() {
	_imagist = imagist.New()
}

// Upload validates and saves create file
func Upload(fileName string, fileContent []byte, options *UploadOptions) (string, string, error) {
	dirPath := path.Join(options.Dir, options.Destination)
	fileName = slug.Make(buildFileName(fileName))
	filePath := path.Join(options.MediaPrefixURL, options.Destination, fileName)
	fileDiskPath := filepath.Join(dirPath, fileName)

	// Create full directory structure to store image
	if err := os.MkdirAll(dirPath, os.ModePerm); err != nil {
		log.Printf("error creating directories: %v\n", err)
		return fileDiskPath, filePath, err
	}

	// Create file on disk if it does not exist
	if _, err := os.Stat(fileDiskPath); os.IsNotExist(err) {
		if err := ioutil.WriteFile(fileDiskPath, fileContent, _fileMode); err != nil {
			log.Printf("error writing %v: %v\n", fileDiskPath, err)
			return fileDiskPath, filePath, err
		}
	}

	file, err := os.Open(fileDiskPath)
	if err != nil {
		log.Printf("error opening %v: %v\n", fileDiskPath, err)
		return fileDiskPath, filePath, err
	}
	defer file.Close()

	buf, err := ioutil.ReadFile(fileDiskPath)
	if err != nil {
		log.Printf("error reading %v: %v\n", fileDiskPath, err)
		return fileDiskPath, filePath, err
	}

	fileSize := len(buf)
	if options.MaxSize != util.NoLimit && fileSize > options.MaxSize {
		log.Printf("file %v greater than max file size: %v\n", fileName, options.MaxSize)
		return fileDiskPath, filePath, fmt.Errorf("file max size error")
	}

	if options.ConvertTo != "" {
		fileDiskPath, filePath, err = changeExt(fileDiskPath, filePath, options.ConvertTo)
		if err != nil {
			return fileDiskPath, filePath, err
		}
	}

	switch options.FileType {
	case TypeImage:
		_imagist.Add(buf, fileDiskPath, options.ImageDimensions)
	case TypeVideo:
		return fileDiskPath, filePath, fmt.Errorf("not yet implemented")
	default:
		return fileDiskPath, filePath, fmt.Errorf("file type invalid")
	}

	return fileDiskPath, filePath, nil
}

// Delete deletes one file
func Delete(fp string) error {
	if err := os.Remove(fp); err != nil {
		return err
	}
	return nil
}

func buildFileName(oldFilename string) string {
	oldExt := filepath.Ext(oldFilename)
	newFilename := strings.TrimSuffix(oldFilename, oldExt)
	return newFilename + "_" + time.Now().Format("20060102150405") + oldExt
}

func changeExt(fileDiskPath, filepath string, newExt string) (string, string, error) {
	oldExt := path.Ext(fileDiskPath)
	newfileDiskPath := strings.TrimSuffix(fileDiskPath, oldExt) + newExt
	newfilePath := strings.TrimSuffix(filepath, oldExt) + newExt

	if err := os.Rename(fileDiskPath, newfileDiskPath); err != nil {
		return fileDiskPath, filepath, fmt.Errorf("image ext change to jpg failed")
	}

	return newfileDiskPath, newfilePath, nil
}

//httpImageDirHandler is an http.Handler that serves a directory.
// If a generated file is missing, it yields a temporary redirect to the original file.
type httpImageDirHandler struct {
	root http.FileSystem
}

func (s httpImageDirHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	p := r.URL.Path

	var suffix string
	if strings.HasSuffix(p, imagist.SuffixSocial) {
		suffix = imagist.SuffixSocial
	} else if strings.HasSuffix(p, imagist.SuffixThumb) {
		suffix = imagist.SuffixThumb
	} else {
		//a previous attempt to lookup the file resulted into a call to this function
		//do not attempt to look up again
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte("Not found"))
		return
	}

	//todo _imagist.Add
	http.Redirect(w, r, p, http.StatusTemporaryRedirect)
}

//HTTPImageDirHandler serves images from a directory with imagist fallback
func HTTPImageDirHandler(root http.FileSystem) http.Handler {
	h := &httpImageDirHandler{root}
	return web.FileServerWithNotFoundHandler(root, h)
}
