package web

import (
	"net/http"
	"os"
	"path"
	"strings"

	"github.com/gorilla/mux"
	log "github.com/sirupsen/logrus"
)

func lookupContent(root http.FileSystem, upath string) (http.File, os.FileInfo, bool) {
	var (
		err  error
		file http.File
		info os.FileInfo
	)

	if !strings.HasPrefix(upath, "/") {
		upath = "/" + upath
	}

	upath = path.Clean(upath)

	if file, err = root.Open(upath); err != nil {
		return nil, nil, false
	}

	if info, err = file.Stat(); err != nil {
		return nil, nil, false
	}

	if info.IsDir() {
		upath += "/index.html"
		return lookupContent(root, upath+"/index.html")
	}

	return file, info, true
}

type fileHandlerWithFallback struct {
	root     http.FileSystem
	fallback http.File
}

// FileServerWithFallback returns an HTTP static fileserver with a default file fallback if requested url was not found
func FileServerWithFallback(root http.FileSystem, fallback http.File) http.Handler {
	return &fileHandlerWithFallback{root: root, fallback: fallback}
}

func (f *fileHandlerWithFallback) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	var (
		file http.File
		info os.FileInfo
		ok   bool
		err  error
	)

	file, info, ok = lookupContent(f.root, r.URL.Path)

	if !ok {
		file = f.fallback
		if info, err = file.Stat(); err == nil {
			ok = true
		}
	}

	if ok {
		http.ServeContent(w, r, info.Name(), info.ModTime(), file)
	} else {
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.Header().Set("X-Content-Type-Options", "nosniff")
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte("File not found and default could not be served."))
	}
}

type fileHandlerWithNotFoundHandler struct {
	root    http.FileSystem
	handler http.Handler
}

// FileServerWithNotFoundHandler returns an HTTP static fileserver with a custom http.Handler if requested url was not found
func FileServerWithNotFoundHandler(root http.FileSystem, handler http.Handler) http.Handler {
	return &fileHandlerWithNotFoundHandler{root: root, handler: handler}
}

func (f *fileHandlerWithNotFoundHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if file, info, ok := lookupContent(f.root, r.URL.Path); ok {
		http.ServeContent(w, r, info.Name(), info.ModTime(), file)
	} else {
		f.handler.ServeHTTP(w, r)
	}
}

// VueAppRouting returns a new subrouter
func VueAppRouting(router *mux.Router, prefix string, appName string, mwf ...mux.MiddlewareFunc) error {
	var (
		fileSystem   http.FileSystem
		fallbackFile http.File
		err          error
	)

	fallbackFile, err = core.Assets.Open("web/" + appName + "/index.html")
	if err != nil {
		return err
	}
	
	fileSystem = util.WebBox{Box: core.Assets, App: "web/" + appName, Path: "/" + appName}

	router.PathPrefix(prefix).Handler(
		http.StripPrefix(
			prefix,
			FileServerWithFallback(fileSystem, fallbackFile),
		),
	)

	return nil
}

// DevRouting returns a new subrouter
func DevRouting(router *mux.Router, prefix string, app string, port string, mwf ...mux.MiddlewareFunc) error {
	var (
		url		  = &url.URL{Scheme: "http", Host: "localhost:" + port}
		wsprox    = NewWSReverseProxy(url)
		htprox    = httputil.NewSingleHostReverseProxy(url)
	)

	router.PathPrefix(prefix).HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if IsWebsocket(r) {
			wsprox.ServeHTTP(w, r)
		} else {
			htprox.ServeHTTP(w, r)
		}
	})

	return nil
}
