package web

import (
	"net/http"
	"os"
	"path"
	"strings"
)

func lookupContent(root http.FileSystem, upath string) (http.File, os.FileInfo, bool) {
	var (
		err  error
		file http.File
		info os.FileInfo
	)

	if !strings.HasPrefix(upath, "/") {
		upath = "/" + upath
	}

	upath = path.Clean(upath)

	if file, err = root.Open(upath); err != nil {
		return nil, nil, false
	}

	if info, err = file.Stat(); err != nil {
		return nil, nil, false
	}

	if info.IsDir() {
		upath += "/index.html"
		return lookupContent(root, upath+"/index.html")
	}

	return file, info, true
}

type fileHandlerWithFallback struct {
	root     http.FileSystem
	fallback http.File
}

// FileServerWithFallback returns an HTTP static fileserver with a default file fallback if requested url was not found
func FileServerWithFallback(root http.FileSystem, fallback http.File) http.Handler {
	return &fileHandlerWithFallback{root: root, fallback: fallback}
}

func (f *fileHandlerWithFallback) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	var (
		file http.File
		info os.FileInfo
		ok   bool
		err  error
	)

	file, info, ok = lookupContent(f.root, r.URL.Path)

	if !ok {
		file = f.fallback
		if info, err = file.Stat(); err == nil {
			ok = true
		}
	}

	if ok {
		http.ServeContent(w, r, info.Name(), info.ModTime(), file)
	} else {
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		w.Header().Set("X-Content-Type-Options", "nosniff")
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte("File not found and default could not be served."))
	}
}

type fileHandlerWithNotFoundHandler struct {
	root    http.FileSystem
	handler http.Handler
}

// FileServerWithNotFoundHandler returns an HTTP static fileserver with a custom http.Handler if requested url was not found
func FileServerWithNotFoundHandler(root http.FileSystem, handler http.Handler) http.Handler {
	return &fileHandlerWithNotFoundHandler{root: root, handler: handler}
}

func (f *fileHandlerWithNotFoundHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if file, info, ok := lookupContent(f.root, r.URL.Path); ok {
		http.ServeContent(w, r, info.Name(), info.ModTime(), file)
	} else {
		f.handler.ServeHTTP(w, r)
	}
}

// NewSubrouter returns a new subrouter
func NewSubrouter(router *mux.Router, prefix string, appName string, mwf ...mux.MiddlewareFunc) (*mux.Router, error) {
	subRouter := router.PathPrefix(prefix).Methods("GET", "HEAD").Subrouter()
	if mwf != nil {
		subRouter.Use(mwf...)
	}

	var (
		fileSystem   http.FileSystem
		fallbackFile http.File
		err          error
	)
	{{if .Bootstrap.Assets}}
	if app.Env == app.EnvironmentDev {
		distDir := "web/" + appName + "/dist"
		fallbackFile, err = os.Open(distDir + "/index.html")

		if err == nil {
			fileSystem = http.Dir(distDir)
		} else {
			log.WithFields(log.Fields{
				"prefix":   prefix,
				"app name": appName,
				"error":    err,
			}).Warn("Could not create sub route")
			return nil
		}
	} else {
		fallbackFile, err = app.Assets.Open("web/" + appName + "/index.html")

		if err != nil {
			return err
		}

		fileSystem = util.WebBox{Box: app.Assets, App: "web/" + appName, Path: "/" + appName}
	}
	{{else}}
	distDir := "web/" + appName + "/dist"
	fallbackFile, err = os.Open(distDir + "/index.html")
	
	if err == nil {
		fileSystem = http.Dir(distDir)
	} else {
		log.WithFields(log.Fields{
			"prefix":   prefix,
			"app name": appName,
			"error":    err,
		}).Warn("Could not create sub route")
		return nil
	}
	{{end}}

	subRouter.PathPrefix("/").Handler(
		http.StripPrefix(
			prefix,
			FileServerWithFallback(fileSystem, fallbackFile),
		),
	)

	return subRouter, nil
}